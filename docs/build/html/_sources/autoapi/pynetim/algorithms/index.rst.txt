pynetim.algorithms
==================

.. py:module:: pynetim.algorithms


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/pynetim/algorithms/RIS_algorithm/index
   /autoapi/pynetim/algorithms/base_algorithm/index
   /autoapi/pynetim/algorithms/heuristic_algorithm/index
   /autoapi/pynetim/algorithms/simulation_algorithm/index


Classes
-------

.. autoapisummary::

   pynetim.algorithms.SingleDiscountAlgorithm
   pynetim.algorithms.DegreeDiscountAlgorithm
   pynetim.algorithms.GreedyAlgorithm
   pynetim.algorithms.CELFAlgorithm
   pynetim.algorithms.BaseRISAlgorithm
   pynetim.algorithms.IMMAlgorithm


Package Contents
----------------

.. py:class:: SingleDiscountAlgorithm(graph: pynetim.graph.IMGraph, diffusion_model=None)

   Bases: :py:obj:`pynetim.algorithms.base_algorithm.BaseAlgorithm`


   简单度折扣启发式算法(Single Discount)用于选择影响力最大化种子节点。

   该算法通过逐步选择具有最高度数的节点作为种子，并对其邻居节点的度数进行折扣，
   以避免选择过多相互连接的节点。


   .. py:method:: run(k: int)

      运行简单度折扣算法选择k个种子节点。

      :param k: 需要选择的种子节点数量
      :type k: int

      :returns: 选择的种子节点列表
      :rtype: list



.. py:class:: DegreeDiscountAlgorithm(graph: pynetim.graph.IMGraph, diffusion_model='IC')

   Bases: :py:obj:`pynetim.algorithms.base_algorithm.BaseAlgorithm`


   度折扣启发式算法(Degree Discount)用于选择影响力最大化种子节点。

   该算法是Single Discount的改进版本，考虑了邻居节点之间的影响关系，
   使用更复杂的折扣公式来更好地评估节点的边际影响力。


   .. py:method:: run(k: int)

      运行度折扣算法选择k个种子节点。

      :param k: 需要选择的种子节点数量
      :type k: int

      :returns: 选择的种子节点列表
      :rtype: list



.. py:class:: GreedyAlgorithm(graph: pynetim.graph.IMGraph, diffusion_model: pynetim.diffusion_model.BaseDiffusionModel)

   Bases: :py:obj:`pynetim.algorithms.base_algorithm.BaseAlgorithm`


   贪婪算法 (Greedy) 选择影响力最大化种子节点

   该算法通过迭代地选择具有最大边际影响力的节点作为种子节点，
   直到选够k个种子节点。每次选择都需要计算所有候选节点的边际增益。

   .. attribute:: graph

      输入图对象

      :type: IMGraph

   .. attribute:: diffusion_model_class

      影响传播模型类

      :type: BaseDiffusionModel


   .. py:attribute:: diffusion_model_class


   .. py:method:: run(k: int, round: int, multi_process=False, processes=None, show_progress=True, seed: int = None)

      运行贪婪算法选择影响力最大化种子节点。

      :param k: 种子节点数量
      :type k: int
      :param round: 每次计算边际增益的蒙特卡洛模拟次数
      :type round: int
      :param multi_process: 是否启用多进程模式，默认为False
      :type multi_process: bool, optional
      :param processes: 多进程模式下的进程数，为None时使用默认值
      :type processes: int, optional
      :param show_progress: 是否显示进度条，默认为True
      :type show_progress: bool, optional
      :param seed: 模拟的随机种子，默认为None
      :type seed: int, optional

      :returns: 选择的种子节点列表
      :rtype: list



.. py:class:: CELFAlgorithm(graph: pynetim.graph.IMGraph, diffusion_model: pynetim.diffusion_model.BaseDiffusionModel)

   Bases: :py:obj:`pynetim.algorithms.base_algorithm.BaseAlgorithm`


   CELF算法选择影响力最大化种子节点

   CELF (Cost-Effective Lazy Forward) 算法是贪婪算法的优化版本，
   利用边际增益的子模特性减少计算量，通过优先队列维护节点的边际增益，
   避免重复计算已失效的边际增益。

   .. attribute:: graph

      输入图对象

      :type: IMGraph

   .. attribute:: diffusion_model_class

      影响传播模型类

      :type: BaseDiffusionModel


   .. py:attribute:: diffusion_model_class


   .. py:method:: run(k: int, round: int, multi_process=False, processes=None, show_progress=True, seed: int = None)

      运行CELF算法选择影响力最大化种子节点。

      :param k: 种子节点数量
      :type k: int
      :param round: 蒙特卡洛模拟次数
      :type round: int
      :param multi_process: 是否启用多进程模式，默认为False
      :type multi_process: bool, optional
      :param processes: 多进程模式下的进程数，为None时使用默认值
      :type processes: int, optional
      :param show_progress: 是否显示进度条，默认为True
      :type show_progress: bool, optional
      :param seed: 模拟的随机数种子，默认为None
      :type seed: int, optional

      :returns: 选择的种子节点列表
      :rtype: list



.. py:class:: BaseRISAlgorithm(graph: pynetim.graph.IMGraph, diffusion_model: str = 'IC', multi_process: bool = False, processes: int = None, seed: int = None)

   Bases: :py:obj:`pynetim.algorithms.base_algorithm.BaseAlgorithm`


   最简版反向影响采样算法(Reverse Influence Sampling, RIS)

   说明:
   - 不自动估计采样数量
   - 用户指定RR集合数量(num_rr_sets)
   - 使用堆优化贪心选择(O(R log k)而非O(R k))
   - 支持IC/LT模型

   .. attribute:: graph

      输入图对象

      :type: IMGraph

   .. attribute:: model

      扩散模型名称('IC'或'LT')

      :type: str

   .. attribute:: nodes

      图中所有节点的列表

      :type: list

   .. attribute:: rr_func

      用于生成RR集合的函数

      :type: Callable

   .. attribute:: multi_process

      是否启用多进程模式

      :type: bool

   .. attribute:: processes

      多进程模式下的进程数

      :type: int

   .. attribute:: seed

      随机种子

      :type: int


   .. py:attribute:: graph


   .. py:attribute:: model
      :value: ''



   .. py:attribute:: nodes


   .. py:attribute:: multi_process
      :value: False



   .. py:attribute:: seed
      :value: None



   .. py:method:: run(k: int, num_rr_sets: int) -> List[int]

      执行简单RIS算法。

      :param k: 种子集合大小
      :type k: int
      :param num_rr_sets: RR集合采样数量（越大越准）
      :type num_rr_sets: int

      :returns: 选出的k个种子节点
      :rtype: Set[int]



.. py:class:: IMMAlgorithm(graph: pynetim.graph.IMGraph, diffusion_model: str = 'IC', eps: float = 0.5, l: int = 1, multi_process: bool = False, processes: int = None, seed: int = None)

   Bases: :py:obj:`BaseRISAlgorithm`


   基于鞅的影响力最大化算法(Influence Maximization via Martingales, IMM)

   支持IC和LT两种扩散模型

   .. attribute:: eps

      近似参数ε

      :type: float

   .. attribute:: l

      失败概率参数l

      :type: float


   .. py:attribute:: eps
      :value: 0.5



   .. py:attribute:: l


   .. py:method:: run(k: int) -> List[int]

      执行IMM算法，返回大小为k的种子集合。

      :param k: 需要选择的种子节点数量
      :type k: int

      :returns: 选出的种子节点集合
      :rtype: Set[int]



